<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Digit AI — Live Neural Network</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Sora:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
/* ============================================================
   CSS VARIABLES — LIGHT & DARK THEMES
   ============================================================ */
:root {
  --font-display: 'Sora', sans-serif;
  --font-mono: 'JetBrains Mono', monospace;
  --radius: 14px;
  --radius-sm: 8px;
  --radius-xs: 5px;
  --transition: 0.25s cubic-bezier(0.4, 0, 0.2, 1);
}

[data-theme="light"] {
  --bg-base: #f0f2f5;
  --bg-surface: #ffffff;
  --bg-surface-hover: #f8f9fb;
  --bg-elevated: #ffffff;
  --bg-inset: #e8ebef;
  --border: #d8dce3;
  --border-subtle: #e8ebef;
  --text-primary: #0d1117;
  --text-secondary: #525a65;
  --text-muted: #8b929c;
  --text-on-accent: #ffffff;
  --accent: #4f46e5;
  --accent-hover: #4338ca;
  --accent-soft: rgba(79, 70, 229, 0.1);
  --accent-glow: rgba(79, 70, 229, 0.25);
  --success: #059669;
  --success-soft: rgba(5, 150, 105, 0.1);
  --warning: #d97706;
  --warning-soft: rgba(217, 119, 6, 0.1);
  --error: #dc2626;
  --error-soft: rgba(220, 38, 38, 0.1);
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.06), 0 1px 2px rgba(0,0,0,0.04);
  --shadow-md: 0 4px 16px rgba(0,0,0,0.08);
  --shadow-lg: 0 12px 40px rgba(0,0,0,0.1);
  --shadow-glow: 0 0 30px rgba(79, 70, 229, 0.15);
  --canvas-bg: #f8f9fb;
  --canvas-grid: #e0e3e8;
  --chart-grid: rgba(0,0,0,0.06);
  --network-bg: linear-gradient(135deg, #f8f9fb 0%, #eef0f4 100%);
  --neuron-idle: #d1d5db;
  --neuron-active: #4f46e5;
  --connection-idle: rgba(0,0,0,0.04);
  --connection-active: rgba(79, 70, 229, 0.5);
  --bar-bg: #e8ebef;
  --logo-gradient: linear-gradient(135deg, #4f46e5, #7c3aed, #a855f7);
}

[data-theme="dark"] {
  --bg-base: #0b0e14;
  --bg-surface: #141820;
  --bg-surface-hover: #1a1f2b;
  --bg-elevated: #1a1f2b;
  --bg-inset: #0f1219;
  --border: #252b37;
  --border-subtle: #1e2430;
  --text-primary: #e6eaf0;
  --text-secondary: #8b929c;
  --text-muted: #5c6370;
  --text-on-accent: #ffffff;
  --accent: #6366f1;
  --accent-hover: #818cf8;
  --accent-soft: rgba(99, 102, 241, 0.12);
  --accent-glow: rgba(99, 102, 241, 0.3);
  --success: #34d399;
  --success-soft: rgba(52, 211, 153, 0.12);
  --warning: #fbbf24;
  --warning-soft: rgba(251, 191, 36, 0.12);
  --error: #f87171;
  --error-soft: rgba(248, 113, 113, 0.12);
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.3);
  --shadow-md: 0 4px 16px rgba(0,0,0,0.4);
  --shadow-lg: 0 12px 40px rgba(0,0,0,0.5);
  --shadow-glow: 0 0 40px rgba(99, 102, 241, 0.2);
  --canvas-bg: #0f1219;
  --canvas-grid: #1e2430;
  --chart-grid: rgba(255,255,255,0.04);
  --network-bg: linear-gradient(135deg, #0f1219 0%, #141820 100%);
  --neuron-idle: #2a3040;
  --neuron-active: #6366f1;
  --connection-idle: rgba(255,255,255,0.03);
  --connection-active: rgba(99, 102, 241, 0.5);
  --bar-bg: #1e2430;
  --logo-gradient: linear-gradient(135deg, #6366f1, #a78bfa, #c084fc);
}

/* ============================================================
   RESET & BASE
   ============================================================ */
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: var(--font-display);
  background: var(--bg-base);
  color: var(--text-primary);
  min-height: 100vh;
  line-height: 1.5;
  -webkit-font-smoothing: antialiased;
  transition: background var(--transition), color var(--transition);
}

/* ============================================================
   LAYOUT
   ============================================================ */
.app { max-width: 1280px; margin: 0 auto; padding: 1.25rem; }

.header {
  display: flex; justify-content: space-between; align-items: center;
  padding: 0.75rem 0; margin-bottom: 1.5rem;
}

.logo { display: flex; align-items: center; gap: 0.6rem; }

.logo-mark {
  width: 36px; height: 36px; border-radius: 10px;
  background: var(--logo-gradient);
  display: flex; align-items: center; justify-content: center;
  font-family: var(--font-mono); font-weight: 700; font-size: 0.9rem;
  color: #fff; box-shadow: 0 2px 12px rgba(99, 102, 241, 0.3);
}

.logo-text {
  font-size: 1.3rem; font-weight: 700; letter-spacing: -0.03em;
  background: var(--logo-gradient);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  background-clip: text;
}

.header-controls { display: flex; align-items: center; gap: 0.75rem; }

/* Theme Toggle */
.theme-toggle {
  width: 44px; height: 24px; border-radius: 12px; border: none;
  background: var(--bg-inset); cursor: pointer; position: relative;
  transition: background var(--transition);
  border: 1px solid var(--border-subtle);
}
.theme-toggle::after {
  content: ''; position: absolute; top: 2px; left: 2px;
  width: 18px; height: 18px; border-radius: 50%;
  background: var(--accent); transition: transform var(--transition);
  box-shadow: 0 1px 4px rgba(0,0,0,0.2);
}
[data-theme="dark"] .theme-toggle::after { transform: translateX(20px); }
.theme-icon { position: absolute; top: 3px; font-size: 12px; line-height: 18px; }
.theme-icon.sun { left: 5px; }
.theme-icon.moon { right: 5px; }

/* Status Pill */
.status-pill {
  display: flex; align-items: center; gap: 0.4rem;
  padding: 0.3rem 0.75rem; border-radius: 20px;
  background: var(--success-soft); font-size: 0.75rem;
  font-weight: 500; color: var(--success);
}
.status-pill.offline { background: var(--error-soft); color: var(--error); }
.status-pill.training { background: var(--warning-soft); color: var(--warning); }
.status-dot {
  width: 6px; height: 6px; border-radius: 50%;
  background: currentColor; animation: pulse 2s ease-in-out infinite;
}
@keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.4; } }

/* ============================================================
   CARDS
   ============================================================ */
.card {
  background: var(--bg-surface); border: 1px solid var(--border);
  border-radius: var(--radius); padding: 1.25rem;
  box-shadow: var(--shadow-sm);
  transition: background var(--transition), border-color var(--transition), box-shadow var(--transition);
}
.card-header {
  display: flex; justify-content: space-between; align-items: center;
  margin-bottom: 1rem;
}
.card-title {
  font-size: 0.85rem; font-weight: 600; text-transform: uppercase;
  letter-spacing: 0.06em; color: var(--text-muted);
}
.card-badge {
  font-family: var(--font-mono); font-size: 0.7rem; padding: 0.15rem 0.5rem;
  border-radius: 4px; background: var(--accent-soft); color: var(--accent);
  font-weight: 600;
}

/* ============================================================
   SECTION: TITLE
   ============================================================ */
.section-title {
  text-align: center; margin-bottom: 1.5rem;
}
.section-title h1 {
  font-size: 1.6rem; font-weight: 700; letter-spacing: -0.03em;
}
.section-title p {
  color: var(--text-secondary); font-size: 0.9rem; margin-top: 0.25rem;
}

/* ============================================================
   NEURAL NETWORK VISUALIZATION
   ============================================================ */
.network-card {
  padding: 1.5rem; margin-bottom: 1.5rem;
  background: var(--network-bg); overflow: hidden;
  position: relative;
}
.network-card::before {
  content: ''; position: absolute; inset: 0; pointer-events: none;
  background: radial-gradient(ellipse at 50% 50%, var(--accent-glow), transparent 70%);
  opacity: 0; transition: opacity 0.5s;
}
.network-card.active::before { opacity: 1; }

#networkCanvas {
  width: 100%; height: 220px; display: block;
}

.network-labels {
  display: flex; justify-content: space-between; padding: 0.75rem 2rem 0;
}
.network-label {
  font-size: 0.7rem; font-weight: 600; text-transform: uppercase;
  letter-spacing: 0.08em; color: var(--text-muted);
}

/* ============================================================
   MAIN GRID
   ============================================================ */
.main-grid {
  display: grid; grid-template-columns: 340px 1fr;
  gap: 1.5rem; align-items: start;
}

@media (max-width: 900px) {
  .main-grid { grid-template-columns: 1fr; }
}

/* ============================================================
   DRAWING CANVAS
   ============================================================ */
.canvas-area { display: flex; flex-direction: column; gap: 1rem; }

.canvas-wrapper {
  position: relative; aspect-ratio: 1; width: 100%;
  background: #000000; border-radius: var(--radius-sm);
  border: 2px solid var(--border); overflow: hidden;
  cursor: crosshair;
}

#drawCanvas {
  width: 100%; height: 100%; display: block;
  touch-action: none;
}

/* Grid overlay */
.canvas-wrapper::after {
  content: ''; position: absolute; inset: 0; pointer-events: none;
  background-image:
    linear-gradient(rgba(255,255,255,0.06) 1px, transparent 1px),
    linear-gradient(90deg, rgba(255,255,255,0.06) 1px, transparent 1px);
  background-size: calc(100%/28) calc(100%/28);
  opacity: 0.8;
}

.canvas-buttons {
  display: flex; gap: 0.5rem;
}

.btn {
  flex: 1; padding: 0.6rem 1rem; border: 1px solid var(--border);
  border-radius: var(--radius-sm); background: var(--bg-surface);
  color: var(--text-primary); font-family: var(--font-display);
  font-size: 0.8rem; font-weight: 500; cursor: pointer;
  transition: all var(--transition); display: flex;
  align-items: center; justify-content: center; gap: 0.4rem;
}
.btn:hover { background: var(--bg-surface-hover); border-color: var(--accent); }
.btn-accent {
  background: var(--accent); color: var(--text-on-accent);
  border-color: var(--accent);
}
.btn-accent:hover { background: var(--accent-hover); }
.btn-danger { color: var(--error); }
.btn-danger:hover { background: var(--error-soft); border-color: var(--error); }

.btn svg { width: 14px; height: 14px; }

/* ============================================================
   PREDICTION HERO
   ============================================================ */
.prediction-hero {
  display: flex; align-items: center; gap: 1rem;
  padding: 1rem; background: var(--bg-inset);
  border-radius: var(--radius-sm); border: 1px solid var(--border-subtle);
}
.predicted-digit {
  width: 64px; height: 64px; display: flex;
  align-items: center; justify-content: center;
  font-family: var(--font-mono); font-size: 2.4rem; font-weight: 700;
  color: var(--accent); background: var(--accent-soft);
  border-radius: var(--radius-sm); transition: all 0.3s;
  border: 2px solid transparent;
}
.predicted-digit.active {
  border-color: var(--accent);
  box-shadow: 0 0 20px var(--accent-glow);
}
.prediction-meta { flex: 1; }
.prediction-meta .label {
  font-size: 0.7rem; font-weight: 600; text-transform: uppercase;
  letter-spacing: 0.06em; color: var(--text-muted);
}
.prediction-meta .confidence {
  font-family: var(--font-mono); font-size: 1.5rem; font-weight: 700;
}
.prediction-meta .inference-time {
  font-family: var(--font-mono); font-size: 0.75rem; color: var(--text-muted);
}

/* ============================================================
   TRAINING STATUS
   ============================================================ */
.training-stats {
  display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;
}
.stat-box {
  padding: 0.6rem; background: var(--bg-inset);
  border-radius: var(--radius-xs); border: 1px solid var(--border-subtle);
}
.stat-box .stat-label {
  font-size: 0.65rem; font-weight: 600; text-transform: uppercase;
  letter-spacing: 0.06em; color: var(--text-muted); margin-bottom: 0.15rem;
}
.stat-box .stat-value {
  font-family: var(--font-mono); font-size: 1rem; font-weight: 600;
}
.stat-box .stat-value.success { color: var(--success); }
.stat-box .stat-value.accent { color: var(--accent); }
.stat-box .stat-value.warning { color: var(--warning); }

/* ============================================================
   RIGHT COLUMN: LIVE METRICS
   ============================================================ */
.right-col { display: flex; flex-direction: column; gap: 1.5rem; }

/* Charts */
.charts-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
@media (max-width: 700px) { .charts-grid { grid-template-columns: 1fr; } }

.chart-container {
  aspect-ratio: 2/1; position: relative;
}
.chart-container canvas { width: 100% !important; height: 100% !important; }

/* Confidence Bars */
.confidence-bars { display: flex; flex-direction: column; gap: 0.4rem; }

.conf-row {
  display: flex; align-items: center; gap: 0.5rem;
  height: 28px;
}
.conf-label {
  font-family: var(--font-mono); font-size: 0.75rem; font-weight: 600;
  width: 16px; text-align: center; color: var(--text-muted);
}
.conf-bar-track {
  flex: 1; height: 22px; background: var(--bar-bg);
  border-radius: 4px; overflow: hidden; position: relative;
}
.conf-bar-fill {
  height: 100%; border-radius: 4px;
  background: var(--accent); opacity: 0.5;
  width: 0%; transition: width 0.15s ease-out, opacity 0.15s;
}
.conf-bar-fill.predicted {
  opacity: 1;
  background: linear-gradient(90deg, var(--accent), var(--accent-hover));
  box-shadow: 0 0 8px var(--accent-glow);
}
.conf-value {
  font-family: var(--font-mono); font-size: 0.7rem; font-weight: 600;
  width: 44px; text-align: right; color: var(--text-muted);
  transition: color 0.15s;
}
.conf-value.predicted { color: var(--accent); font-weight: 700; }

/* ============================================================
   STATUS BAR
   ============================================================ */
.status-bar {
  font-family: var(--font-mono); font-size: 0.7rem;
  color: var(--text-muted); padding: 0.5rem 0;
  display: flex; justify-content: space-between;
}

/* ============================================================
   TRAINING MODAL
   ============================================================ */
.modal-overlay {
  display: none; position: fixed; inset: 0; z-index: 100;
  background: rgba(0,0,0,0.5); backdrop-filter: blur(4px);
  align-items: center; justify-content: center;
}
.modal-overlay.show { display: flex; }
.modal {
  background: var(--bg-surface); border: 1px solid var(--border);
  border-radius: var(--radius); padding: 2rem; max-width: 420px;
  width: 90%; box-shadow: var(--shadow-lg);
}
.modal h2 {
  font-size: 1.1rem; font-weight: 700; margin-bottom: 0.5rem;
}
.modal p { color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 1.25rem; }

.epoch-slider-group { margin-bottom: 1.25rem; }
.epoch-slider-group label {
  display: flex; justify-content: space-between;
  font-size: 0.8rem; font-weight: 500; margin-bottom: 0.4rem;
}
.epoch-slider-group label span { font-family: var(--font-mono); color: var(--accent); }
input[type="range"] {
  width: 100%; height: 4px; -webkit-appearance: none;
  background: var(--bar-bg); border-radius: 2px; outline: none;
}
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none; width: 16px; height: 16px;
  border-radius: 50%; background: var(--accent); cursor: pointer;
  box-shadow: 0 0 6px var(--accent-glow);
}

.modal-buttons { display: flex; gap: 0.5rem; }
.modal-buttons .btn { flex: 1; }

/* ============================================================
   TRAINING PROGRESS OVERLAY
   ============================================================ */
.training-progress {
  display: none; margin-top: 0.75rem;
}
.training-progress.show { display: block; }
.progress-track {
  width: 100%; height: 6px; background: var(--bar-bg);
  border-radius: 3px; overflow: hidden; margin-bottom: 0.4rem;
}
.progress-fill {
  height: 100%; background: var(--accent); border-radius: 3px;
  width: 0%; transition: width 0.5s;
}
.progress-text {
  font-family: var(--font-mono); font-size: 0.7rem;
  color: var(--text-secondary); display: flex;
  justify-content: space-between;
}

/* ============================================================
   SCROLLBAR
   ============================================================ */
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

/* ============================================================
   ANIMATIONS
   ============================================================ */
@keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }
.fade-in { animation: fadeIn 0.4s ease-out forwards; }
</style>
</head>
<body>

<div class="app">
  <!-- HEADER -->
  <header class="header">
    <div class="logo">
      <div class="logo-mark">AI</div>
      <span class="logo-text">Digit AI</span>
    </div>
    <div class="header-controls">
      <div class="status-pill" id="statusPill">
        <span class="status-dot"></span>
        <span id="statusText">Connecting...</span>
      </div>
      <button class="theme-toggle" id="themeToggle" title="Toggle theme">
        <span class="theme-icon sun">☀</span>
        <span class="theme-icon moon">☾</span>
      </button>
    </div>
  </header>

  <!-- TITLE -->
  <div class="section-title">
    <h1>Live Neural Network Visualization</h1>
    <p>Draw a digit and watch the network think in real time</p>
  </div>

  <!-- NEURAL NETWORK VIZ -->
  <div class="card network-card" id="networkCard">
    <canvas id="networkCanvas"></canvas>
    <div class="network-labels">
      <span class="network-label">Input Layer</span>
      <span class="network-label">Conv → FC Hidden</span>
      <span class="network-label">Output (0–9)</span>
    </div>
  </div>

  <!-- MAIN GRID -->
  <div class="main-grid">
    <!-- LEFT: Canvas & Controls -->
    <div class="canvas-area">
      <!-- Drawing Canvas -->
      <div class="card">
        <div class="card-header">
          <span class="card-title">Drawing Canvas</span>
          <span class="card-badge">28×28</span>
        </div>
        <div class="canvas-wrapper">
          <canvas id="drawCanvas"></canvas>
        </div>
        <div class="canvas-buttons" style="margin-top:0.75rem">
          <button class="btn" id="btnClear">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 6h18M8 6V4a1 1 0 011-1h6a1 1 0 011 1v2m2 0v12a2 2 0 01-2 2H8a2 2 0 01-2-2V6h12z"/></svg>
            Clear
          </button>
          <button class="btn btn-accent" id="btnTrain">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"/></svg>
            Train Model
          </button>
          <button class="btn btn-danger" id="btnReset">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 4v6h6M23 20v-6h-6"/><path d="M20.49 9A9 9 0 005.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 013.51 15"/></svg>
            Reset
          </button>
        </div>
      </div>

      <!-- Prediction Hero -->
      <div class="card">
        <div class="card-header">
          <span class="card-title">Prediction</span>
          <span class="card-badge" id="modelStatus">No Model</span>
        </div>
        <div class="prediction-hero">
          <div class="predicted-digit" id="predictedDigit">—</div>
          <div class="prediction-meta">
            <div class="label">Confidence</div>
            <div class="confidence" id="confidenceValue">0.0%</div>
            <div class="inference-time" id="inferenceTime">—</div>
          </div>
        </div>
      </div>

      <!-- Training Stats -->
      <div class="card">
        <div class="card-header">
          <span class="card-title">System Status</span>
        </div>
        <div class="training-stats">
          <div class="stat-box">
            <div class="stat-label">Accuracy</div>
            <div class="stat-value success" id="statAccuracy">—</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Inference</div>
            <div class="stat-value accent" id="statInference">—</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Loss</div>
            <div class="stat-value warning" id="statLoss">—</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Device</div>
            <div class="stat-value" id="statDevice">—</div>
          </div>
        </div>
        <div class="training-progress" id="trainingProgress">
          <div class="progress-track"><div class="progress-fill" id="progressFill"></div></div>
          <div class="progress-text">
            <span id="progressEpoch">Epoch 0/0</span>
            <span id="progressAcc">0%</span>
          </div>
        </div>
      </div>
    </div>

    <!-- RIGHT: Live Metrics -->
    <div class="right-col">
      <!-- Charts -->
      <div class="card">
        <div class="card-header">
          <span class="card-title">Training Metrics</span>
          <span class="card-badge" id="epochBadge">0 Epochs</span>
        </div>
        <div class="charts-grid">
          <div>
            <div style="font-size:0.7rem;font-weight:600;color:var(--text-muted);margin-bottom:0.4rem;text-transform:uppercase;letter-spacing:0.05em;">Accuracy (%)</div>
            <div class="chart-container"><canvas id="chartAccuracy"></canvas></div>
          </div>
          <div>
            <div style="font-size:0.7rem;font-weight:600;color:var(--text-muted);margin-bottom:0.4rem;text-transform:uppercase;letter-spacing:0.05em;">Loss</div>
            <div class="chart-container"><canvas id="chartLoss"></canvas></div>
          </div>
        </div>
      </div>

      <!-- Confidence Bars -->
      <div class="card">
        <div class="card-header">
          <span class="card-title">Prediction Confidence</span>
          <span class="card-badge">Real-Time</span>
        </div>
        <div class="confidence-bars" id="confidenceBars"></div>
      </div>
    </div>
  </div>

  <!-- Status Bar -->
  <div class="status-bar">
    <span id="footerStatus">Status: Waiting for connection...</span>
    <span id="footerFPS">0 FPS</span>
  </div>
</div>

<!-- TRAINING MODAL -->
<div class="modal-overlay" id="trainModal">
  <div class="modal">
    <h2>Train Neural Network</h2>
    <p>This will download MNIST data (~12MB on first run) and train a CNN. Your 5070 Ti should handle this in a few minutes.</p>
    <div class="epoch-slider-group">
      <label>Epochs <span id="epochCount">15</span></label>
      <input type="range" id="epochSlider" min="5" max="30" value="15" step="1">
    </div>
    <div class="modal-buttons">
      <button class="btn" id="modalCancel">Cancel</button>
      <button class="btn btn-accent" id="modalStart">Start Training</button>
    </div>
  </div>
</div>

<script>
/* ============================================================
   DIGIT AI — CLIENT APPLICATION
   Real-time WebSocket inference, network visualization, charts
   ============================================================ */

// === THEME TOGGLE ===
const themeToggle = document.getElementById('themeToggle');
const savedTheme = localStorage.getItem('digit-ai-theme') || 'dark';
document.documentElement.setAttribute('data-theme', savedTheme);

themeToggle.addEventListener('click', () => {
  const current = document.documentElement.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  document.documentElement.setAttribute('data-theme', next);
  localStorage.setItem('digit-ai-theme', next);
  drawNetworkIdle();
  renderCharts();
});

// === DOM REFS ===
const $ = id => document.getElementById(id);
const networkCanvas = $('networkCanvas');
const networkCtx = networkCanvas.getContext('2d');
const drawCanvasEl = $('drawCanvas');
const drawCtx = drawCanvasEl.getContext('2d');

// === CONFIDENCE BARS INIT ===
const barsContainer = $('confidenceBars');
for (let i = 0; i < 10; i++) {
  barsContainer.innerHTML += `
    <div class="conf-row">
      <span class="conf-label">${i}</span>
      <div class="conf-bar-track"><div class="conf-bar-fill" id="bar${i}"></div></div>
      <span class="conf-value" id="val${i}">0.0%</span>
    </div>`;
}

// === DRAWING CANVAS ===
const CANVAS_SIZE = 280;
let isDrawing = false;
let hasContent = false;
let lastX, lastY;

function initDrawCanvas() {
  const wrapper = drawCanvasEl.parentElement;
  const size = wrapper.clientWidth;
  drawCanvasEl.width = size;
  drawCanvasEl.height = size;
  drawCtx.lineCap = 'round';
  drawCtx.lineJoin = 'round';
  clearCanvas();
}

function clearCanvas() {
  // Fill with black background (MNIST standard: black bg, white digit)
  drawCtx.fillStyle = '#000000';
  drawCtx.fillRect(0, 0, drawCanvasEl.width, drawCanvasEl.height);
  hasContent = false;
  updatePredictionUI(null);
}

function getPos(e) {
  const rect = drawCanvasEl.getBoundingClientRect();
  const touch = e.touches ? e.touches[0] : e;
  return {
    x: (touch.clientX - rect.left) * (drawCanvasEl.width / rect.width),
    y: (touch.clientY - rect.top) * (drawCanvasEl.height / rect.height)
  };
}

function startDraw(e) {
  e.preventDefault();
  isDrawing = true;
  const p = getPos(e);
  lastX = p.x; lastY = p.y;
}

function draw(e) {
  if (!isDrawing) return;
  e.preventDefault();
  const p = getPos(e);
  // Always draw WHITE strokes on BLACK bg (MNIST standard)
  drawCtx.strokeStyle = '#ffffff';
  drawCtx.lineWidth = drawCanvasEl.width / 14;
  drawCtx.beginPath();
  drawCtx.moveTo(lastX, lastY);
  drawCtx.lineTo(p.x, p.y);
  drawCtx.stroke();
  lastX = p.x; lastY = p.y;
  hasContent = true;
  requestPrediction();
}

function endDraw() {
  isDrawing = false;
  if (hasContent) requestPrediction();
}

drawCanvasEl.addEventListener('mousedown', startDraw);
drawCanvasEl.addEventListener('mousemove', draw);
drawCanvasEl.addEventListener('mouseup', endDraw);
drawCanvasEl.addEventListener('mouseleave', endDraw);
drawCanvasEl.addEventListener('touchstart', startDraw, { passive: false });
drawCanvasEl.addEventListener('touchmove', draw, { passive: false });
drawCanvasEl.addEventListener('touchend', endDraw);

function getPixelData() {
  // Step 1: Get the raw canvas as grayscale
  const srcW = drawCanvasEl.width;
  const srcH = drawCanvasEl.height;
  const srcData = drawCtx.getImageData(0, 0, srcW, srcH);

  // Step 2: Find bounding box of the drawn content
  let minX = srcW, minY = srcH, maxX = 0, maxY = 0;
  let found = false;
  for (let y = 0; y < srcH; y++) {
    for (let x = 0; x < srcW; x++) {
      const idx = (y * srcW + x) * 4;
      const r = srcData.data[idx];
      const g = srcData.data[idx + 1];
      const b = srcData.data[idx + 2];
      const brightness = 0.299 * r + 0.587 * g + 0.114 * b;
      if (brightness > 30) { // non-black pixel (part of the digit)
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
        found = true;
      }
    }
  }

  if (!found) {
    return new Array(784).fill(0);
  }

  // Step 3: Crop to bounding box, then place centered in 20x20 area 
  // with 4px padding on each side (MNIST standard)
  const cropW = maxX - minX + 1;
  const cropH = maxY - minY + 1;

  // Create centered 28x28 image
  const tmp = document.createElement('canvas');
  tmp.width = 28; tmp.height = 28;
  const tc = tmp.getContext('2d');

  // Black background
  tc.fillStyle = '#000000';
  tc.fillRect(0, 0, 28, 28);

  // Fit into 20x20 center area (4px padding)
  const targetSize = 20;
  const scale = Math.min(targetSize / cropW, targetSize / cropH);
  const drawW = cropW * scale;
  const drawH = cropH * scale;
  const offsetX = (28 - drawW) / 2;
  const offsetY = (28 - drawH) / 2;

  tc.imageSmoothingEnabled = true;
  tc.imageSmoothingQuality = 'high';
  tc.drawImage(drawCanvasEl, minX, minY, cropW, cropH, offsetX, offsetY, drawW, drawH);

  // Step 4: Extract grayscale values (already white-on-black, no inversion needed)
  const imgData = tc.getImageData(0, 0, 28, 28);
  const pixels = new Float32Array(784);
  for (let i = 0; i < 784; i++) {
    const r = imgData.data[i * 4];
    const g = imgData.data[i * 4 + 1];
    const b = imgData.data[i * 4 + 2];
    pixels[i] = 0.299 * r + 0.587 * g + 0.114 * b;
  }
  return Array.from(pixels);
}

// === WEBSOCKET ===
let ws = null;
let wsConnected = false;
let pendingPredict = false;
let lastPredictTime = 0;
const PREDICT_THROTTLE = 50; // ms

function connectWS() {
  const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
  ws = new WebSocket(`${proto}//${location.host}/ws`);

  ws.onopen = () => {
    wsConnected = true;
    setStatus('online', 'Live');
    $('footerStatus').textContent = 'Status: Live inference running...';
  };

  ws.onmessage = (e) => {
    const msg = JSON.parse(e.data);
    handleMessage(msg);
  };

  ws.onclose = () => {
    wsConnected = false;
    setStatus('offline', 'Disconnected');
    setTimeout(connectWS, 2000);
  };

  ws.onerror = () => {
    wsConnected = false;
  };
}

function handleMessage(msg) {
  switch (msg.type) {
    case 'init':
      if (msg.data.model_loaded) {
        $('modelStatus').textContent = 'Ready';
        $('modelStatus').style.color = '';
      }
      $('statDevice').textContent = msg.data.device || '—';
      if (msg.data.training_history?.accuracy?.length) {
        trainingData = msg.data.training_history;
        renderCharts();
        const acc = trainingData.accuracy;
        $('statAccuracy').textContent = acc[acc.length-1] + '%';
        $('epochBadge').textContent = acc.length + ' Epochs';
      }
      break;

    case 'prediction':
      handlePrediction(msg.data);
      pendingPredict = false;
      break;

    case 'training_started':
      setStatus('training', 'Training...');
      $('trainingProgress').classList.add('show');
      $('modelStatus').textContent = 'Training';
      break;

    case 'training_complete':
      setStatus('online', 'Live');
      $('trainingProgress').classList.remove('show');
      $('modelStatus').textContent = 'Ready';
      if (msg.data.history) {
        trainingData = msg.data.history;
        renderCharts();
        $('statAccuracy').textContent = msg.data.accuracy + '%';
        $('epochBadge').textContent = msg.data.epochs + ' Epochs';
      }
      break;

    case 'training_update':
      updateTrainingProgress(msg.data);
      break;

    case 'model_reset':
      $('modelStatus').textContent = 'No Model';
      trainingData = { train_loss: [], test_loss: [], accuracy: [] };
      renderCharts();
      clearCanvas();
      break;

    case 'pong':
      break;
  }
}

function setStatus(type, text) {
  const pill = $('statusPill');
  pill.className = 'status-pill' + (type === 'offline' ? ' offline' : type === 'training' ? ' training' : '');
  $('statusText').textContent = text;
}

function requestPrediction() {
  if (!wsConnected || !hasContent || pendingPredict) return;
  const now = Date.now();
  if (now - lastPredictTime < PREDICT_THROTTLE) return;
  lastPredictTime = now;
  pendingPredict = true;

  ws.send(JSON.stringify({
    type: 'predict',
    data: { pixels: getPixelData() }
  }));
}

function handlePrediction(data) {
  if (data.error) return;
  updatePredictionUI(data);
  drawNetwork(data.activations, data.probabilities, data.digit);
  updateFPS(data.inference_ms);
}

// === FPS COUNTER ===
let fpsHistory = [];
function updateFPS(ms) {
  fpsHistory.push(ms);
  if (fpsHistory.length > 30) fpsHistory.shift();
  const avg = fpsHistory.reduce((a, b) => a + b, 0) / fpsHistory.length;
  const fps = Math.round(1000 / avg);
  $('footerFPS').textContent = fps + ' FPS';
  $('statInference').textContent = avg.toFixed(1) + ' ms';
}

// === UPDATE UI ===
function updatePredictionUI(data) {
  if (!data) {
    $('predictedDigit').textContent = '—';
    $('predictedDigit').classList.remove('active');
    $('confidenceValue').textContent = '0.0%';
    $('inferenceTime').textContent = '—';
    for (let i = 0; i < 10; i++) {
      $('bar' + i).style.width = '0%';
      $('bar' + i).className = 'conf-bar-fill';
      $('val' + i).textContent = '0.0%';
      $('val' + i).className = 'conf-value';
    }
    return;
  }

  $('predictedDigit').textContent = data.digit;
  $('predictedDigit').classList.add('active');
  $('confidenceValue').textContent = data.confidence + '%';
  $('inferenceTime').textContent = data.inference_ms + ' ms';

  for (let i = 0; i < 10; i++) {
    const p = data.probabilities[i];
    $('bar' + i).style.width = p + '%';
    $('val' + i).textContent = p.toFixed(1) + '%';
    if (i === data.digit) {
      $('bar' + i).className = 'conf-bar-fill predicted';
      $('val' + i).className = 'conf-value predicted';
    } else {
      $('bar' + i).className = 'conf-bar-fill';
      $('val' + i).className = 'conf-value';
    }
  }
}

function updateTrainingProgress(data) {
  const pct = (data.epoch / data.total_epochs) * 100;
  $('progressFill').style.width = pct + '%';
  $('progressEpoch').textContent = `Epoch ${data.epoch}/${data.total_epochs}`;
  $('progressAcc').textContent = data.accuracy + '%';
  $('statAccuracy').textContent = data.accuracy + '%';
  $('statLoss').textContent = data.test_loss.toFixed(4);

  // Live chart update
  if (!trainingData.accuracy) trainingData = { train_loss: [], test_loss: [], accuracy: [] };
  trainingData.accuracy.push(data.accuracy);
  trainingData.train_loss.push(data.train_loss);
  trainingData.test_loss.push(data.test_loss);
  renderCharts();
  $('epochBadge').textContent = data.epoch + ' Epochs';
}

// === NEURAL NETWORK VISUALIZATION ===
function resizeNetworkCanvas() {
  const rect = networkCanvas.parentElement.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  networkCanvas.width = rect.width * dpr;
  networkCanvas.height = 220 * dpr;
  networkCtx.scale(dpr, dpr);
  networkCanvas.style.width = rect.width + 'px';
  networkCanvas.style.height = '220px';
}

function getThemeColors() {
  const cs = getComputedStyle(document.documentElement);
  return {
    neuronIdle: cs.getPropertyValue('--neuron-idle').trim(),
    neuronActive: cs.getPropertyValue('--neuron-active').trim(),
    connIdle: cs.getPropertyValue('--connection-idle').trim(),
    connActive: cs.getPropertyValue('--connection-active').trim(),
    text: cs.getPropertyValue('--text-muted').trim(),
    accent: cs.getPropertyValue('--accent').trim(),
    accentGlow: cs.getPropertyValue('--accent-glow').trim(),
    surface: cs.getPropertyValue('--bg-surface').trim(),
  };
}

// Layer config: [input_sample, conv1(16), conv2(32), fc1(128->sampled), output(10)]
const LAYERS = [
  { count: 12, label: 'Input' },
  { count: 8, label: 'Conv1' },
  { count: 10, label: 'Conv2' },
  { count: 10, label: 'FC' },
  { count: 10, label: 'Output' },
];

function getNeuronPositions(w, h) {
  const pad = 50;
  const layerGap = (w - pad * 2) / (LAYERS.length - 1);
  const positions = [];

  for (let l = 0; l < LAYERS.length; l++) {
    const x = pad + l * layerGap;
    const n = LAYERS[l].count;
    const totalH = h - 40;
    const gap = Math.min(18, totalH / (n + 1));
    const startY = (h - (n - 1) * gap) / 2;
    const layer = [];
    for (let i = 0; i < n; i++) {
      layer.push({ x, y: startY + i * gap });
    }
    positions.push(layer);
  }
  return positions;
}

function drawNetworkIdle() {
  resizeNetworkCanvas();
  const w = networkCanvas.width / (window.devicePixelRatio || 1);
  const h = networkCanvas.height / (window.devicePixelRatio || 1);
  const c = getThemeColors();
  const pos = getNeuronPositions(w, h);

  networkCtx.clearRect(0, 0, w, h);

  // Connections
  for (let l = 0; l < pos.length - 1; l++) {
    for (let i = 0; i < pos[l].length; i++) {
      for (let j = 0; j < pos[l+1].length; j++) {
        networkCtx.beginPath();
        networkCtx.moveTo(pos[l][i].x, pos[l][i].y);
        networkCtx.lineTo(pos[l+1][j].x, pos[l+1][j].y);
        networkCtx.strokeStyle = c.connIdle;
        networkCtx.lineWidth = 0.5;
        networkCtx.stroke();
      }
    }
  }

  // Neurons
  for (let l = 0; l < pos.length; l++) {
    for (const n of pos[l]) {
      networkCtx.beginPath();
      networkCtx.arc(n.x, n.y, 5, 0, Math.PI * 2);
      networkCtx.fillStyle = c.neuronIdle;
      networkCtx.fill();
    }
  }

  $('networkCard').classList.remove('active');
}

function drawNetwork(activations, probabilities, predicted) {
  if (!activations || Object.keys(activations).length === 0) return drawNetworkIdle();

  resizeNetworkCanvas();
  const w = networkCanvas.width / (window.devicePixelRatio || 1);
  const h = networkCanvas.height / (window.devicePixelRatio || 1);
  const c = getThemeColors();
  const pos = getNeuronPositions(w, h);

  // Build activation values per layer
  const acts = [
    Array(LAYERS[0].count).fill(0.3), // Input placeholder
    (activations.conv1 || []).slice(0, LAYERS[1].count),
    (activations.conv2 || []).slice(0, LAYERS[2].count),
    (activations.fc1 || []).slice(0, LAYERS[3].count),
    (probabilities || []).map(p => p / 100),
  ];

  // Pad
  for (let l = 0; l < acts.length; l++) {
    while (acts[l].length < LAYERS[l].count) acts[l].push(0);
  }

  networkCtx.clearRect(0, 0, w, h);

  // Connections with activation
  for (let l = 0; l < pos.length - 1; l++) {
    for (let i = 0; i < pos[l].length; i++) {
      for (let j = 0; j < pos[l+1].length; j++) {
        const strength = Math.min(1, (acts[l][i] + acts[l+1][j]) / 2);
        if (strength < 0.05) continue;
        networkCtx.beginPath();
        networkCtx.moveTo(pos[l][i].x, pos[l][i].y);
        networkCtx.lineTo(pos[l+1][j].x, pos[l+1][j].y);
        networkCtx.strokeStyle = strength > 0.3
          ? c.connActive.replace('0.5', strength.toFixed(2))
          : c.connIdle;
        networkCtx.lineWidth = 0.3 + strength * 1.5;
        networkCtx.stroke();
      }
    }
  }

  // Neurons with glow
  for (let l = 0; l < pos.length; l++) {
    for (let i = 0; i < pos[l].length; i++) {
      const n = pos[l][i];
      const a = acts[l][i] || 0;
      const r = 4 + a * 3;

      if (a > 0.3) {
        networkCtx.beginPath();
        networkCtx.arc(n.x, n.y, r + 6, 0, Math.PI * 2);
        const grd = networkCtx.createRadialGradient(n.x, n.y, r, n.x, n.y, r + 6);
        grd.addColorStop(0, c.accentGlow);
        grd.addColorStop(1, 'transparent');
        networkCtx.fillStyle = grd;
        networkCtx.fill();
      }

      networkCtx.beginPath();
      networkCtx.arc(n.x, n.y, r, 0, Math.PI * 2);
      networkCtx.fillStyle = a > 0.1 ? c.neuronActive : c.neuronIdle;
      networkCtx.globalAlpha = 0.3 + a * 0.7;
      networkCtx.fill();
      networkCtx.globalAlpha = 1;

      // Output layer labels
      if (l === pos.length - 1) {
        networkCtx.font = '600 9px "JetBrains Mono"';
        networkCtx.fillStyle = i === predicted ? c.accent : c.text;
        networkCtx.textAlign = 'left';
        networkCtx.fillText(i.toString(), n.x + r + 6, n.y + 3);

        if (i === predicted) {
          // Highlight predicted
          networkCtx.beginPath();
          networkCtx.arc(n.x, n.y, r + 3, 0, Math.PI * 2);
          networkCtx.strokeStyle = c.accent;
          networkCtx.lineWidth = 2;
          networkCtx.stroke();

          networkCtx.font = '700 10px "JetBrains Mono"';
          networkCtx.fillStyle = c.accent;
          networkCtx.fillText((probabilities[i]).toFixed(0) + '%', n.x + r + 18, n.y + 3);
        }
      }
    }
  }

  $('networkCard').classList.add('active');
}

// === CHARTS ===
let trainingData = { train_loss: [], test_loss: [], accuracy: [] };

function renderCharts() {
  renderChart('chartAccuracy', trainingData.accuracy || [], {
    color: getComputedStyle(document.documentElement).getPropertyValue('--success').trim(),
    minY: 90, maxY: 100, suffix: '%'
  });
  renderChart('chartLoss', trainingData.train_loss || [], {
    color: getComputedStyle(document.documentElement).getPropertyValue('--warning').trim(),
    minY: 0, maxY: null, suffix: ''
  });
}

function renderChart(canvasId, data, opts) {
  const canvas = $(canvasId);
  const ctx = canvas.getContext('2d');
  const rect = canvas.parentElement.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);
  canvas.style.width = rect.width + 'px';
  canvas.style.height = rect.height + 'px';

  const w = rect.width;
  const h = rect.height;
  const pad = { top: 10, right: 10, bottom: 20, left: 40 };
  const chartW = w - pad.left - pad.right;
  const chartH = h - pad.top - pad.bottom;

  ctx.clearRect(0, 0, w, h);

  if (!data.length) {
    ctx.font = '500 11px "Sora"';
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-muted').trim();
    ctx.textAlign = 'center';
    ctx.fillText('No data yet — train the model', w / 2, h / 2);
    return;
  }

  const minY = opts.minY ?? Math.min(...data) * 0.95;
  const maxY = opts.maxY ?? Math.max(...data) * 1.05;
  const rangeY = maxY - minY || 1;

  const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-grid').trim();
  const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-muted').trim();

  // Grid lines
  ctx.strokeStyle = gridColor;
  ctx.lineWidth = 1;
  for (let i = 0; i <= 4; i++) {
    const y = pad.top + (chartH / 4) * i;
    ctx.beginPath();
    ctx.moveTo(pad.left, y);
    ctx.lineTo(w - pad.right, y);
    ctx.stroke();

    const val = maxY - (rangeY / 4) * i;
    ctx.font = '500 9px "JetBrains Mono"';
    ctx.fillStyle = textColor;
    ctx.textAlign = 'right';
    ctx.fillText(val.toFixed(val > 10 ? 1 : 3) + opts.suffix, pad.left - 6, y + 3);
  }

  // X labels
  if (data.length > 1) {
    ctx.font = '500 9px "JetBrains Mono"';
    ctx.fillStyle = textColor;
    ctx.textAlign = 'center';
    ctx.fillText('1', pad.left, h - 4);
    ctx.fillText(data.length.toString(), w - pad.right, h - 4);
  }

  // Line
  const stepX = data.length > 1 ? chartW / (data.length - 1) : 0;
  ctx.beginPath();
  for (let i = 0; i < data.length; i++) {
    const x = pad.left + i * stepX;
    const y = pad.top + chartH - ((data[i] - minY) / rangeY) * chartH;
    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
  }
  ctx.strokeStyle = opts.color;
  ctx.lineWidth = 2;
  ctx.lineJoin = 'round';
  ctx.stroke();

  // Fill
  const lastX = pad.left + (data.length - 1) * stepX;
  ctx.lineTo(lastX, pad.top + chartH);
  ctx.lineTo(pad.left, pad.top + chartH);
  ctx.closePath();
  const grd = ctx.createLinearGradient(0, pad.top, 0, pad.top + chartH);
  grd.addColorStop(0, opts.color + '30');
  grd.addColorStop(1, opts.color + '05');
  ctx.fillStyle = grd;
  ctx.fill();

  // Dots
  for (let i = 0; i < data.length; i++) {
    const x = pad.left + i * stepX;
    const y = pad.top + chartH - ((data[i] - minY) / rangeY) * chartH;
    ctx.beginPath();
    ctx.arc(x, y, 3, 0, Math.PI * 2);
    ctx.fillStyle = opts.color;
    ctx.fill();
  }
}

// === BUTTONS ===
$('btnClear').addEventListener('click', clearCanvas);

$('btnTrain').addEventListener('click', () => {
  $('trainModal').classList.add('show');
});
$('modalCancel').addEventListener('click', () => {
  $('trainModal').classList.remove('show');
});
$('epochSlider').addEventListener('input', (e) => {
  $('epochCount').textContent = e.target.value;
});
$('modalStart').addEventListener('click', () => {
  const epochs = parseInt($('epochSlider').value);
  $('trainModal').classList.remove('show');
  trainingData = { train_loss: [], test_loss: [], accuracy: [] };
  ws.send(JSON.stringify({ type: 'train', data: { epochs } }));
});

$('btnReset').addEventListener('click', () => {
  if (confirm('Reset model? This will delete the trained weights.')) {
    ws.send(JSON.stringify({ type: 'reset_model' }));
  }
});

// === HEARTBEAT ===
setInterval(() => {
  if (wsConnected) ws.send(JSON.stringify({ type: 'ping' }));
}, 15000);

// === RESIZE ===
window.addEventListener('resize', () => {
  initDrawCanvas();
  drawNetworkIdle();
  renderCharts();
});

// === INIT ===
initDrawCanvas();
drawNetworkIdle();
renderCharts();
connectWS();
</script>
</body>
</html>